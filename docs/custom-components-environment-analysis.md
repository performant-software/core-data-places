# Custom Components: Environment Compatibility Analysis

## Overview

This document analyzes how each proposed custom components approach behaves across the three primary environments used by Core Data Places:

1. **Local Development** (`TINA_PUBLIC_IS_LOCAL=true`)
2. **SSR Website** (`STATIC_BUILD=false`, output: 'server')
3. **Static Website** (`STATIC_BUILD=true`, output: 'static')

## Current Environment Architecture

### Local Development
- `TINA_PUBLIC_IS_LOCAL=true`
- `TINA_LOCAL_CONTENT_PATH=../../my-content-repo` (relative path to local content repo)
- TinaCMS reads directly from local file system
- No git clone during build (`build.content.mjs` skips if no GITHUB_OWNER/GITHUB_REPO)
- Hot reload active
- Dev server: `netlify dev` with Astro dev mode

### SSR Website (Production)
- `STATIC_BUILD=false` (default)
- Astro config: `output: 'server'`
- Adapter: Netlify Functions
- Build script clones content repo from GitHub
- Server-rendered at request time
- TinaCMS integration for content editing

### Static Website (Prebuilt)
- `STATIC_BUILD=true`
- Astro config: `output: 'static'`
- All pages pre-rendered at build time
- Build script clones content repo from GitHub
- No server runtime, pure static HTML/JS/CSS
- TinaCMS typically disabled

## Approach Comparison by Environment

---

## Approach A: File System Copy

### How It Works Per Environment

#### Local Development
**Content Source:** Local file system via `TINA_LOCAL_CONTENT_PATH`
**Component Copy:** Need to handle local path resolution

**Implementation:**
```javascript
// scripts/build.content.mjs (modified)
export const fetchContent = async () => {
  const isLocal = process.env.TINA_PUBLIC_IS_LOCAL === 'true';
  const localPath = process.env.TINA_LOCAL_CONTENT_PATH;

  if (isLocal && localPath) {
    // Local development: copy from local path
    if (fs.existsSync(`${localPath}/content`)) {
      fs.cpSync(`${localPath}/content`, './content', { recursive: true });
    }
    if (fs.existsSync(`${localPath}/components`)) {
      fs.cpSync(`${localPath}/components`, './src/components/custom', {
        recursive: true
      });
    }
    return;
  }

  if (!(process.env.GITHUB_OWNER && process.env.GITHUB_REPO)) {
    return;
  }

  // Production: clone from GitHub
  const TEMP_DIR = './tmp';
  if (fs.existsSync(TEMP_DIR)) {
    fs.rmSync(TEMP_DIR, { recursive: true });
  }

  const url = `https://github.com/${process.env.GITHUB_OWNER}/${process.env.GITHUB_REPO}.git`;
  child_process.execSync(`git clone ${url} ${TEMP_DIR}`);

  fs.cpSync(`${TEMP_DIR}/content`, './content', { recursive: true });

  // Copy components if they exist
  if (fs.existsSync(`${TEMP_DIR}/components`)) {
    fs.cpSync(`${TEMP_DIR}/components`, './src/components/custom', {
      recursive: true
    });
  }

  fs.rmSync(TEMP_DIR, { recursive: true });
};
```

**Pros:**
- ✅ Works seamlessly in local dev
- ✅ Changes to components reflected on dev server restart
- ✅ Can use file watcher for auto-reload (with additional tooling)

**Cons:**
- ⚠️ Requires dev server restart to see component changes
- ⚠️ Need to handle both local and remote paths

#### SSR Website
**Content Source:** GitHub repo cloned at build time
**Component Copy:** Happens during build, copied to `src/components/custom`

**Pros:**
- ✅ Components bundled with build, available at runtime
- ✅ No runtime dependencies on content repo
- ✅ Standard Vite/Astro import resolution
- ✅ Works with Netlify Functions

**Cons:**
- ⚠️ Component updates require full rebuild and redeploy
- ⚠️ No dynamic component loading

#### Static Website
**Content Source:** GitHub repo cloned at build time
**Component Copy:** Happens during build, all components bundled

**Pros:**
- ✅ All components pre-bundled in static build
- ✅ No runtime overhead
- ✅ Perfect for CDN deployment
- ✅ Components become part of static assets

**Cons:**
- ⚠️ Component updates require full rebuild
- ⚠️ Larger bundle size if many custom components

### Overall Verdict for Approach A
**✅ WORKS WELL IN ALL ENVIRONMENTS**

All three environments supported with same implementation. Build script handles both local and remote sources correctly.

---

## Approach B: Virtual Module with Dynamic Registry

### How It Works Per Environment

#### Local Development
**Content Source:** Local file system
**Component Registry:** Generated by Vite plugin on-the-fly

**Implementation Considerations:**
```javascript
// Vite plugin needs to watch local content path
export function customComponentsPlugin() {
  const isLocal = process.env.TINA_PUBLIC_IS_LOCAL === 'true';
  const localPath = process.env.TINA_LOCAL_CONTENT_PATH;

  return {
    name: 'vite-plugin-custom-components',

    // Watch for component changes in local dev
    configureServer(server) {
      if (isLocal && localPath) {
        const componentsPath = `${localPath}/components`;
        server.watcher.add(componentsPath);

        server.watcher.on('change', (file) => {
          if (file.startsWith(componentsPath)) {
            // Invalidate virtual module
            const mod = server.moduleGraph.getModuleById(RESOLVED_ID);
            if (mod) {
              server.moduleGraph.invalidateModule(mod);
              server.ws.send({ type: 'full-reload' });
            }
          }
        });
      }
    },

    resolveId(id) {
      if (id === VIRTUAL_MODULE_ID) {
        return RESOLVED_ID;
      }
    },

    load(id) {
      if (id === RESOLVED_ID) {
        const componentsPath = isLocal && localPath
          ? `${localPath}/components`
          : './src/components/custom';

        if (!fs.existsSync(componentsPath)) {
          return 'export default {};';
        }

        // Scan and generate exports...
        const files = fs.readdirSync(componentsPath, { recursive: true });
        // ... generate module code
      }
    }
  };
}
```

**Pros:**
- ✅ Can read directly from local content repo (no copy needed)
- ✅ File watcher can trigger HMR
- ✅ Dynamic component discovery
- ✅ Best developer experience for component authors

**Cons:**
- ⚠️ More complex Vite plugin implementation
- ⚠️ Need to handle both local and copied paths
- ⚠️ Virtual module may confuse some developers

#### SSR Website
**Content Source:** GitHub repo cloned at build time
**Component Registry:** Generated at build time, remains static at runtime

**Pros:**
- ✅ Virtual module resolved at build time
- ✅ Components bundled with application
- ✅ Works with Netlify Functions
- ✅ Clean import syntax

**Cons:**
- ⚠️ Component updates require rebuild
- ⚠️ Virtual module adds abstraction layer
- ⚠️ Debugging can be trickier

#### Static Website
**Content Source:** GitHub repo cloned at build time
**Component Registry:** Generated and frozen at build time

**Pros:**
- ✅ All components compiled into static bundle
- ✅ Virtual module resolved at build time
- ✅ No runtime overhead

**Cons:**
- ⚠️ Component updates require rebuild
- ⚠️ More complex build pipeline to debug

### Overall Verdict for Approach B
**✅ WORKS IN ALL ENVIRONMENTS** (with caveats)

Works well but requires more sophisticated implementation. Best local dev experience if file watching is implemented correctly. Static and SSR work fine but add complexity without major benefits over Approach A.

---

## Approach C: NPM Package Pattern

### How It Works Per Environment

#### Local Development
**Content Source:** npm dependency (via git URL or npm link)
**Component Loading:** Standard npm resolution

**Implementation Options:**

**Option 1: npm link**
```bash
# In content repo
cd ~/my-content-repo
npm link

# In Core Data Places repo
cd ~/repos/core-data-places
npm link @my-org/project-content
```

**Option 2: file: protocol**
```json
// package.json
{
  "dependencies": {
    "@my-org/project-content": "file:../my-content-repo"
  }
}
```

**Pros:**
- ✅ Standard npm workflow
- ✅ No special build script logic needed
- ✅ Works with npm link for hot reload
- ✅ Best TypeScript/IDE support
- ✅ Mirrors production behavior

**Cons:**
- ⚠️ Requires npm link or file: protocol setup
- ⚠️ Developers need to understand npm linking
- ⚠️ Content repo needs package.json setup
- ⚠️ May need to run `npm install` after component changes
- ⚠️ `file:` protocol copies files, breaking live updates

#### SSR Website
**Content Source:** npm install from git URL at build time
**Component Loading:** Standard npm resolution

**Build Process:**
```bash
# In Netlify build
npm install # Installs git dependency
npm run build # Components available via node_modules
```

**package.json:**
```json
{
  "dependencies": {
    "@my-org/project-content": "github:my-org/content-repo#main"
  }
}
```

**Pros:**
- ✅ Standard npm dependency management
- ✅ Proper versioning via git tags/branches
- ✅ Works perfectly with Netlify build process
- ✅ Can cache node_modules
- ✅ Clear separation: content fetched via npm, not custom script
- ✅ Multiple projects can share same package

**Cons:**
- ⚠️ Component updates require updating dependency version/hash
- ⚠️ Need GitHub auth for private repos in CI
- ⚠️ Build script still needs to copy `/content` folder (TinaCMS expects it locally)

**Modified Build Script:**
```javascript
// scripts/build.content.mjs
export const fetchContent = async () => {
  // Only fetch TinaCMS content, not components
  // Components come from node_modules/@my-org/project-content

  const isLocal = process.env.TINA_PUBLIC_IS_LOCAL === 'true';
  const localPath = process.env.TINA_LOCAL_CONTENT_PATH;

  if (isLocal && localPath) {
    if (fs.existsSync(`${localPath}/content`)) {
      fs.cpSync(`${localPath}/content`, './content', { recursive: true });
    }
    // Components handled by npm link/file:
    return;
  }

  // In production, content comes from GitHub
  // But we might also have components in node_modules if using Approach C
  // So only copy content, not components
  if (process.env.GITHUB_OWNER && process.env.GITHUB_REPO) {
    const TEMP_DIR = './tmp';
    if (fs.existsSync(TEMP_DIR)) {
      fs.rmSync(TEMP_DIR, { recursive: true });
    }

    const url = `https://github.com/${process.env.GITHUB_OWNER}/${process.env.GITHUB_REPO}.git`;
    child_process.execSync(`git clone ${url} ${TEMP_DIR}`);

    // Only copy content
    fs.cpSync(`${TEMP_DIR}/content`, './content', { recursive: true });

    fs.rmSync(TEMP_DIR, { recursive: true });
  }
};
```

#### Static Website
**Content Source:** npm install from git URL at build time
**Component Loading:** Standard npm resolution, bundled at build time

**Pros:**
- ✅ Components compiled into static bundle
- ✅ Standard npm workflow
- ✅ Excellent for versioning
- ✅ Can deploy to any static host

**Cons:**
- ⚠️ Component updates require version bump + rebuild
- ⚠️ Larger initial setup

### Overall Verdict for Approach C
**✅ WORKS IN ALL ENVIRONMENTS** (with setup)

Best long-term solution but requires most setup. Local dev needs `npm link` or `file:` protocol. Production is cleanest with proper versioning. Best when multiple projects share components or when component versioning matters.

---

## Environment Compatibility Matrix

| Approach | Local Dev | SSR Website | Static Website | Setup Complexity | Maintenance |
|----------|-----------|-------------|----------------|------------------|-------------|
| **A: File Copy** | ✅ Excellent | ✅ Excellent | ✅ Excellent | Low | Low |
| **B: Virtual Module** | ✅ Excellent* | ✅ Good | ✅ Good | High | Medium |
| **C: NPM Package** | ⚠️ Good** | ✅ Excellent | ✅ Excellent | Medium | Medium |

\* Best with file watching implementation
\** Requires npm link or file: protocol setup

---

## Specific Concerns by Environment

### Local Development Concerns

**All Approaches Need:**
- Support for `TINA_LOCAL_CONTENT_PATH` (relative paths like `../../content-repo`)
- Handle missing components gracefully (new developers)
- Clear error messages if components folder doesn't exist

**Approach A:**
- Modify `build.content.mjs` to handle local path
- Restart dev server when components change

**Approach B:**
- Vite plugin must resolve from local path
- Can implement file watching for HMR
- Best DX if implemented fully

**Approach C:**
- Need clear documentation on `npm link` workflow
- Alternative: use `file:` protocol in local `.env`-based package.json override

### SSR Website Concerns

**All Approaches Work Well**

**Approach A:**
- Components copied to `src/` during build
- Standard Vite bundling
- ✅ No special considerations

**Approach B:**
- Virtual module resolved at build time
- ✅ Works but adds complexity

**Approach C:**
- Components in `node_modules`
- Netlify needs GitHub auth for private repos
- ✅ Most "standard" approach

### Static Website Concerns

**All Approaches Work Well**

**Key Consideration:** All components must be known at build time

**Approach A:**
- ✅ Components copied during build
- ✅ Bundled with static site

**Approach B:**
- ✅ Virtual module resolved during static build
- ✅ All components compiled in

**Approach C:**
- ✅ npm package installed at build time
- ✅ Components bundled in static output
- ✅ Best for CDN caching (versioned)

---

## Recommendations by Use Case

### Recommendation 1: Single Project, Quick Implementation
**Use Approach A (File System Copy)**

All three environments work seamlessly with minimal setup:
- Local: copies from `TINA_LOCAL_CONTENT_PATH`
- SSR/Static: copies from cloned GitHub repo
- Same code path for all environments
- Easy to understand and debug

### Recommendation 2: Multiple Projects Sharing Components
**Use Approach C (NPM Package)**

Best for organizations with multiple Core Data Places instances:
- Shared component library across projects
- Proper versioning and updates
- Standard npm workflow
- Works well in all environments once initial setup is done

### Recommendation 3: Plugin/Extension System
**Use Approach B (Virtual Module)**

If building a plugin ecosystem or need dynamic discovery:
- Can dynamically register components
- Best local dev experience with file watching
- Can generate TypeScript types automatically
- Overkill for simple use cases

---

## Migration Path

### Start with Approach A
1. Implement file system copy (1-2 hours)
2. Test in all three environments
3. Use for 1-2 projects to validate

### Evaluate Migration to C When:
- 3+ projects need same components
- Component versioning becomes important
- Team comfortable with npm package management
- Want better TypeScript/IDE support

### Migration Process (A → C)
1. Add `package.json` to content repo with exports
2. Publish to npm or use git URL in dependencies
3. Update build script to skip component copy
4. Test in local dev with `npm link`
5. Deploy to staging/production

---

## Implementation Checklist by Environment

### For Approach A (Recommended)

#### Local Development Setup
- [ ] Modify `build.content.mjs` to check `TINA_PUBLIC_IS_LOCAL`
- [ ] Copy components from `TINA_LOCAL_CONTENT_PATH` if local
- [ ] Add error handling for missing components folder
- [ ] Update documentation for local setup

#### SSR Website Setup
- [ ] Ensure build script copies components from cloned repo
- [ ] Verify components available in `src/components/custom`
- [ ] Test imports in Astro pages
- [ ] Verify Netlify Functions have access to components

#### Static Website Setup
- [ ] Set `STATIC_BUILD=true` in environment
- [ ] Verify components bundled in static output
- [ ] Check bundle size with custom components
- [ ] Test on static host (Netlify, Vercel, etc.)

### For Approach C (Long-term)

#### Local Development Setup
- [ ] Add `package.json` to content repo
- [ ] Document `npm link` workflow
- [ ] Alternative: document `file:` protocol approach
- [ ] Test HMR with linked package

#### SSR Website Setup
- [ ] Add git dependency to `package.json`
- [ ] Configure GitHub auth in Netlify (if private repo)
- [ ] Modify build script to skip component copy
- [ ] Test component imports from node_modules

#### Static Website Setup
- [ ] Same as SSR, verify static build works
- [ ] Check bundle size and caching
- [ ] Verify CDN compatibility

---

## Conclusion

**All three approaches work across all environments**, but with different trade-offs:

- **Approach A** is the safest, quickest, and most straightforward
- **Approach B** offers the best local DX but adds complexity
- **Approach C** is the most scalable and "proper" but requires setup

For most teams, **start with Approach A** and migrate to **Approach C** when scale demands it.
